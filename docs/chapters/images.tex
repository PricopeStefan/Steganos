
\chapter{Image file formats and steganography techniques}

\section{Introduction}

\setlength\columnsep{20pt}
\begin{multicols}{2}
An image is a two-dimensional representation depicting any possible subject conceivable by human imagination, captured using an optical device (such as a camera or a telescope) or a natural object (human eyes). The image can then be rendered and displayed for other people to see either manually (by painting, carving etc.) or automatically (by using a computer). In this chapter we will focus on images captured using digital optical devices that are rendered automatically. The correct term for them is digital images, but throughout the rest of the paper they will be reffered to as images for convenience.

\begin{figure}[H]
    \centering
    \includegraphics[width=5cm,height=5cm,keepaspectratio]{pics/lenna}
    \caption{Lenna - Classic example of a digital image}
    \label{Lenna}
\end{figure}

Computers are programmed to do operations in a clear sequential way and this rule doesn't change when working with pictures. In order for a computer to be able to render an image, it needs to know some general metadata information about the photo, such as the width and height, as well as the data bytes of the image. These bytes are the actual representation of the picture which compose the two-dimensional pixel map\footnote{This is true for a lossless format, where each pixel is stored in memory. It is not exactly the case for lossy formats such as JPEG where the image goes through processing before being rendered. More information later in the chapter.}. A pixel is the smallest unit that a computer monitor can read and display. The pixel color is the result of merging the different color channels which compose the picture (such as RGB, YUV, YCbCr etc.). Here is an example of the entire process - let's assume that from the image data bytes the first 3 bytes have the decimal values 20, 127, 250 and that it uses the RGB color model. This means that when the computer will have to render the image, the first pixel will have the red component equal to 20 (0x14), the green equal to 127 (0x7F), and the blue equal to 250 (0xFA), in what will finally be interpreted as \#147FFA by the monitor (variation of light blue). 

\begin{figure}[H]
    \centering
    \includegraphics[width=8cm,height=2.15cm,keepaspectratio]{pics/how_a_pixel_works}
    \caption{How 3 colors channels build the pixel}
    \label{Pixel Creation}
\end{figure}

By merging multiple pixels over a two-dimensional space, they will eventually start to resemble an image that can be stored on a disk as a byte stream and can be rendered anytime by parsing the aforementioned stream. Each pixel can be represented as a point in that space with coordinates that are part of the unsigned integer domain. An entire row of pixels, i.e. pixels that have the same ordinate value, is sometimes also referred to as a scanline because in the earlier days of modern computing, computers would be given the width of the image and based on that value they would read a precise amount of bytes and render it on the screen before moving on to the next scanline, repeating this process until there would be no more information.

It is important to note that most of these developments have been done in a time where the maximum storage was extremely limited and not very fast, very different from what it is today. In order to save some space they looked into different compression algorithms to apply to the byte streams and today they fall into two distinict categories: the lossless algorithms are the ones that compress all the original information without destroying any of it, while on the other hand there are the lossy algorithms which are able to identify which information is useless and delete it accordingly. This concept also applies to file formats and we will see in later chapters more concrete examples. 

With all of this information in mind, we can now procede to discussing the most commonly formats commonly used in today's.

\section{BitMap Picture (BMP)} \label{BMP_Explained_Chapter}

The BMP file format, also known as the device independent bitmap file format(DIB), bitmap image file or just bitmap, is a lossless\footnote{It is true that the format specification standards supports compression but further research reveals that currently it only supports lossless types of compression, such as the Huffman or Run Length Encoding algorithms.} image file format originally designed by Microsoft back in 1986 in order to store two-dimensional digital images on their Windows operating system. Over the years it has developed plenty of variations and extensions that were based on the original specification but this paper will focus only on the most common available ones, no extended versions that are looking to improve the format since they do not add anything interesting or new to the way the format stores the data thus affecting the steganography algorithms.

As with almost every file format, the final BMP byte stream can be seen as a result of the merge between the BMP header which contains metadata about the file and the BMP data which is the actual pixel information. As we can see from table \ref{BMP_Header_Table}, the BMP header stores a lot of important information about the image that is useful for any rendering software while making sure to allocate enough memory to be able to display the picture on the screen and other essential steps. It is also important to note that all the structures seen in the BMP header use the little-endian format for representation and are usually more troublesome on the systems that have the default set as big-endian.
\end{multicols}

 \begin{center}
	\begin{tabular}{|l|l|l|l|}
		\hline
		\textbf{Information} & \textbf{Size} & \textbf{Offset} & \textbf{Description} \\ \hline
		Signature & 2 bytes & 0x00 & Two chars, 'B' and 'M' \\ \hline
		File size & 4 bytes & 0x02 & Total file size in bytes \\ \hline
		Reserved & 4 bytes & 0x06 & Unused space \\ \hline
		Data offset & 4 bytes & 0x0A & Offset to get to the actual BMP data \\ \hline
		Size & 4 bytes & 0x0E & Size of the left header information \\ \hline
		Width & 4 bytes & 0x12 & Horizontal size of the image \\ \hline
		Height & 4 bytes & 0x16 & Vertical size of the image \\ \hline
		Planes & 2 bytes & 0x1A & Amount of image planes \\ \hline
		Bits Per Pixel & 2 bytes & 0x1C & How many bits are used to represent each pixel \\ \hline
		Compression & 4 bytes & 0x1E & Indicates the type of compression used \\ \hline
		Image size & 4 bytes & 0x22 & The size of the compressed image, can be 0 \\ \hline
		X pixels per Meter & 4 bytes & 0x26 & Horizontal resolution in pixels/meter \\ \hline
		Y pixels Per Meter & 4 bytes & 0x2A & Vertical resolution in pixels/meter \\ \hline
		Colors Used & 4 bytes & 0x2E & \begin{tabular}[c]{@{}l@{}}Number of actually used colors\\ (based on Bits Per Pixel)\end{tabular} \\ \hline
		Important Colors & 4 bytes & 0x32 & Number of important colors (usually all) \\ \hline
	\end{tabular}
	\label{BMP_Header_Table}
 \end{center}

\begin{multicols}{2}
Analyzing the obligatory BMP header fields we realise that most of them are useless for any steganographic purposes mainly because they can't be altered without having major consequences on the renderer software but there are still a few interesting ones left:
\begin{itemize}
  \item The 4 bytes that are reserved and unused could be very well put to use by using the methods presented in chapter \ref{Unused_Space_Chapter}, so we can use either this space to send parts of a message over multiple BMP files, or we can store the secret message size in these 4 bytes and write the secret after the actual image data has ended.
  \item Data offset could be useful because some renderers use this field to indicate the offset of the actual image data and just skip any other irelevant metadata information, allowing us to hide information in those fields.
  \item The width and the height of the image usually are altered to hide bottom parts of the image that may contain hidden information or by masking the result of the merge of two images and just showing the top one. Let's take for example this image of the sun that is obviously missing a part for demonstration purposes.

\begin{figure}[H]
    \centering
    \includegraphics[width=4cm,keepaspectratio]{pics/height_modification_steganography_cut}
    \caption{Incomplete sun image}
    \label{Sun_Missing_Part}
\end{figure}

However if we adjust by trial and error the height of the image to see if there is any more bytes to render, we would notice that there really is a message hidden with those bytes that some steganalysis softwares would detect but any renderer software such as the Windows Media Viewer would always miss. In other words, we have tricked the software to not display more scanlines than we wanted it to display, even though the information is there, not corrupted in any way.

\begin{figure}[H]
    \centering
    \includegraphics[width=4cm,keepaspectratio]{pics/height_modification_steganography_original}
    \caption{Complete sun including the hidden message}
    \label{Sun_Original}
\end{figure}
\end{itemize}

Moving on from the metadata block of the BMP format to the actual data byte stream, we find additional interesting information about how the pixel data is actually stored. Most images use the Red, Green and Blue also known as RGB values to compose the final pixel color, but for an unknown reason the creators of the bitmap format decided to store the information in the reverse order in the data stream as Blue, Green, Red or BGR. However this is not the only change they made from the other common image formats available at the time: rather than storing the scanlines from a top to down order, BMP decided to store them bottom-up.

\begin{figure}[H]
    \centering
    \includegraphics[width=7cm,keepaspectratio]{pics/assembling_bmp_image}
    \caption{How the BMP image is rendered}
    \label{bmp_how_to_render}
\end{figure}

This behaviour can be noticed in figures \ref{Sun_Missing_Part} and \ref{Sun_Original} where the top part is cropped in order to hide a message and we can now understand why it is only that part that can be made redundant in the steganography process: because the last bytes of the image data binary stream are actually responsible for the rendering of the top section of the picture. Seeing and understanding how the carrier format works is the first and most important step in embedding messages in a covert way.

\subsection{Image sub-block scrambling using the BMP format}
Sub-block scrambling is a type of scrambling algorithm, like those introduced in chapter \ref{scrambling_chapter}, that can be applied to images stored in the BMP format. It was created by the author of this thesis based on the idea of the JPEG format and the algorithm it uses during compression that is applied only on sub-blocks of 8x8 size. We mentioned in chapter \ref{scrambling_chapter} that most scrambling algorithms have \[ MMS \leq [CDS \ / \ 8] \ bytes \] but the target was to design and implement an algorithm which can make use of all the bytes available in the cover, and we ended up with this method which has 
\begin{equation} \label{eq:1}
MMS = [CDS \ / \ 8] \ bytes
\end{equation}
 making it similar in storage capacity to a sequential algorithm. That performance was achieved following a simple procedure:
\begin{itemize}
  \item Separate the image into multiple blocks of BLOCK\_SIZE (this is a global constant value which is usually equal to 8 but can be higher or lower). It doesn't matter if the width or height of the image are not a multiple of BLOCK\_SIZE, the algorithm also works with non-square blocks.
  \item The algorithm needs a password to work with in order to use it as a seed when generating a permutation. Each block calls a helper method to obtain the given permutation for itself based on its own width and height. That permutation is the order in which the data will be written.
  \item The first block is reserved for writing the metadata about the message(such as the length of the secret) and the other blocks are for writing the actual contents of the message.
\end{itemize}

\end{multicols}

\definecolor{lightergray}{rgb}{0.92,0.92,0.92}
\lstset{escapeinside={<@}{@>},
		frame=single,
		xleftmargin=-25.4pt,
	      xrightmargin=-25.4pt
}

\begin{lstlisting}[backgroundcolor = \color{lightergray},language=Python,caption={Pseudocode of the scramble algorithm},captionpos=b,label=lst:scramble_pseudocode]
 global constant BLOCK_SIZE;

 procedure embed_subblock(secret, subblock, random_engine)
   #Generate a permutation from 0 to subblock.width * subblock.height
   #using the random_engine given. That permutation will be the order
   #used when writing the secret data into the subblock data.
   writing_order<@$\gets$@>random_permutation(0,subblock.width*subblock.height,random_engine); 

   for each byte_index in writing_order do
     #Getting the absolute index of the subblock rows and 
     #columns where we need to write the secret information.
     subblock_row<@$\gets$@>subblock.starting_line_index+byte_index/subblock.width;
     subblock_column<@$\gets$@>subblock.starting_column_index+byte_index%subblock.width;
     set_least_significant_bit(subblock.data[subblock_row][subblock_column],secret);

     #We move to the next bit of the secret information
     advance_to_next_secret_bit(secret);
		
 procedure pseudo_scramble(cover, secret, password)
   #Creating a new pseudo-random engine with a given seed.
   random_engine<@$\gets$@>new pseudo_random_engine(password);

   for each subblock of cover with subblock.size<@$\leq$@>BLOCK_SIZE
     if subblock = cover.first_subblock
       #Used for hiding the size of the secret into 
       #the first subblock of the cover in an order
       #given by the pseudo-random engine random_engine.
       embed_subblock(secret.size,subblock,random_engine);
     else
       #If it's not the first subblock of the cover, 
       #write the actual secret into the subblock.
       embed_subblock(secret.iterator,subblock,random_engine);

\end{lstlisting}

\begin{multicols*}{2}
It is much easier to explain the algorithm using a simple example, so let's begin with the image represented in figure \ref{scramble_example_original_image}. It is BMP image with a resolution of 10x6 pixels (10 pixels wide, 6 pixels tall). Furthermore, let's also create the parameters needed by the algorithm in order to embed a message:
\begin{itemize}
  \item The secret message we want to hide in the cover file is "Hello World", no quotes.
  \item Given the aforementioned message, we can calculate its size: 5 characters for the word "Hello", 5 characters for "world" and 1 character for the space inbetween. Total message length is 11 characters or 11 bytes using the ASCII standard. 
  \item The password used for generating the seed is "super\_secret\_key", no quotes.
  \item The BLOCK\_SIZE used in splitting the original image is equal to 4.
\end{itemize}

\begin{figure}[H]
    \centering
    \includegraphics[width=7cm,keepaspectratio]{pics/bmp_scrambling/original_image}
    \caption{Original BMP cover image}
    \label{scramble_example_original_image}
\end{figure}

Knowing all of this information we can already know if the cover file is going to be able to hold the secret message based on the formula \ref{eq:1}. We know that the BMP format uses 3 bytes for storing each pixel and that our image is 10 pixels wide and 6 pixels tall, so we have that 
\\$CDS=3*10*6=180\ bytes \overset{(\ref{eq:1})}{ \implies }\\ \overset{(\ref{eq:1})}{ \implies } MMS=[180/8]=22\ bytes$

Since our total message length is smaller than $MMS$, we know that we will not be running out of cover space during the embedding process. After making these verifications, we can begin by initializing our pseudo-random engine based on the given password meant to be used as a seed and we can also start splitting the original image into sub-blocks, ending up with a result similar to figure \ref{scramble_example_subblocks}. Since neither the width or height of the image are multiples of the BLOCK\_SIZE constant, we have several smaller blocks (to be more precise, blocks 3, 4, 5 and 6) that are still going to be used for embedding purposes. 

\begin{figure}[H]
    \centering
    \includegraphics[width=7cm,keepaspectratio]{pics/bmp_scrambling/image_broken_subblocks}
    \caption{Sub-blocks of the original image}
    \label{scramble_example_subblocks}
\end{figure}

We can now begin the actual embedding process. From the pseudocode presented in listing \ref{lst:scramble_pseudocode} we see that the first step is to embed metadata about the secret message, more specifically its length represented as an unsigned integer on 32 bits. But before we can do that, we must ask the pseudo-random engine to generate a permutation between 0 and $subblock.width * subblock.height$, excluding the last value. For this example specifically, we know that
\[ subblock.width * subblock.height = 4 * 4 = 16 \]
and let's assume that the engine returns us the following permutation: 
\[(5,10,12,3,0,15,4,9,14,13,8,2,7,1,6,11) \]
With this order known and with the fact that each BMP pixel is represented on 3 bytes giving us 3 least significant bits for embedding purposes in mind, the process of embedding the message length (11 or 0x0000000B) into the first subblock goes as follows:
\begin{enumerate}
  \item 5th pixel is the first one, all LSBs are set to 0.
  \item 10th pixel, all 3 LSBs are set to 0.
  \item 12th pixel, all 3 LSBs are set to 0.
  \item 3rd pixel, all 3 LSBs are set to 0.
  \item 0th pixel, all 3 LSBs are set to 0.
  \item 15th pixel, all 3 LSBs are set to 0.
  \item 4th pixel, all 3 LSBs are set to 0.
  \item 9th pixel, all 3 LSBs are set to 0.
  \item 14th pixel, all 3 LSBs are set to 0.
  \item 13th pixel has the Blue channel LSB set to 0, Green channel LSB set to 1, Red channel LSB set to 0.
  \item 8th pixel has the Blue channel LSB set to 1, Green channel LSB set to 1, Red channel is unchanged.
  \item The rest of the pixels are unchanged.
\end{enumerate}

A visual representation of the order based on the given permutation can be found in figure \ref{scramble_example_first_block}. We can also notice that we managed to embed 4 bytes of information into a simple block of 4x4 pixels, or 48 bytes of total data, and we still have 2 bytes of free space based on \ref{eq:1}(one bit available in 8th pixel and 3 bits in pixels 2,7,1,6,11).

\begin{figure}[H]
    \centering
    \includegraphics[width=5cm,keepaspectratio]{pics/bmp_scrambling/first_block_marked}
    \caption{Order of writing into the first block}
    \label{scramble_example_first_block}
\end{figure}

After embedding the metadata, we can begin hiding the actual message data into the subblock bytes. The sub-block size is 4*4 pixels total, which means 48 bytes in total space, resulting in exactly 6 bytes we will be able to write into this subblock (and every other block which uses 3 bytes to store a pixel and has 16 pixels in total). We start by converting our secret message in binary and we end up with something like this:
\begin{enumerate}
\item H = 01001000
\item e = 01100101
\item l = 01101100
\item l = 01101100
\item o = 01101111
\item (space) = 00100000 
\item w = 01110111 
\item o = 01101111 
\item r = 01110010 
\item l = 01101100 
\item d = 01100100
\end{enumerate}
By knowing we have 6 bytes available in the first sub-block we will be able to hide the string "Hello ", which is impressive because it is already more than half of our total message in an image that is only 4 pixels wide and 4 pixels tall. Before starting the actual embedding process, we must again use the pseudo-random engine to generate a new permutation ranging from 0 to the total amount of pixels in the block. Again for the sake of our example, let's assume that we get this permutation:
\[(10,4,12,6,1,15,9,3,0,8,13,5,2,14,7,11)\]
Using the binary conversion of our message, we begin by taking 3 bits each time from the binary stream and embedding them into each channel of a pixel in the order given by the permutation. We can see what bits we have written into which pixels in figure \ref{scramble_example_second_block} (the first bit is the one written into the Blue channel of the pixel, the middle one is the Green channel and the last bit is encoded into the Red channel).

\begin{figure}[H]
    \centering
    \includegraphics[width=6cm,keepaspectratio]{pics/bmp_scrambling/second_block_marked}
    \caption{Order of writing the actual message into the second block}
    \label{scramble_example_second_block}
\end{figure}

In the case of the third block the situation is slightly different because the width of the block is not equal to BLOCK\_SIZE but this change does not change the behaviour of the algorithm at all. In this case we have a block that is 2 pixels wide and 4 pixels tall, ending up with a total of total 24 bytes needed for storage that can accomodate 3 bytes of secret information, or in our case the letters 'w', 'o' and 'r'. In this case we generate a permutation from 0 to 8, excluding the last value:
\[(3,6,0,1,4,7,2,5)\]
By going through the same process as with the previous block we get the result that can be seen in figure \ref{scramble_example_third_block}. This leaves us with the target of hiding only two more characters: 'l' and 'd' in block number 4 which is identical to block 3 in size but was rotated by 90 degrees. 

\begin{figure}[H]
    \centering
    \includegraphics[height=5cm,keepaspectratio]{pics/bmp_scrambling/third_block_marked}
    \caption{Order of writing into the third block}
    \label{scramble_example_third_block}
\end{figure}

For the last time we generate a permutation using the engine in the same interval as above and we obtain:
\[(5,3,0,7,4,2,6,1)\]
And by going again through the steps described above we manage to hide the last two remaining characters and we still have a byte free in the sub-block. The remaining blocks of the image remain unchanged and theoretically could be used for hiding other messages, but there are a few issues that can arise with this, the main one being message separation and identification, how each message is divided etc.

\begin{figure}[H]
    \centering
    \includegraphics[width=5cm,keepaspectratio]{pics/bmp_scrambling/fourth_block_marked}
    \caption{Writing the actual message into the fourth block}
\end{figure}

After the algorithm finishes and the modified cover image is saved, there is absolutely no difference to the human eye between the two pictures. This is the power of Least Significant Bit insertion when using digital images as the carrier format. The only difference between the two files is at a bit level, making it one of the safest and most covert ways of sending secrets over an untrusted environment.

\begin{figure}[H]
    \centering
    \includegraphics[width=5cm,keepaspectratio]{pics/bmp_scrambling/original_image}
    \caption{The original image}
\end{figure}

\begin{figure}[H]
    \centering
    \includegraphics[width=5cm,keepaspectratio]{pics/bmp_scrambling/altered_image}
    \caption{The altered image containing the message "Hello world"}
\end{figure}

Like any other steganography algorithm, this method also has advantages and disadvantages. The main benefits of this algorithm are:
\begin{itemize}
  \item \textbf{Security}. Choosing a BLOCK\_SIZE of only 8, each normal sized block will have a total of 64 pixels and there would be $64! = 1.2688693e+89$ ways available (just for a single block) for the algorithm to write the secret information. Given the fact that each block has its own permutation generated specifically for it based on a pseudo-random engine makes it very hard for any intruders to try and retrieve the secret message without having access to the key. Increasing the size of the BLOCK\_SIZE only strengthens the overall security of the method while still keeping the same message capacity.
 \item \textbf{Efficiency}. The algorithm is extremely fast because it performs very few demanding operations and it is taking advantage of bit-wise operations. Furthermore, there is also the option of adding parallelization because there are no conflicts whatsoever between the parties involved, thus ending in an even more efficiency increase for the entire operation. There could be a small issue regarding the generation of the permutations based on a key in a multi-threaded environment because it may be prone to some implementation language issues with the pseudo-random engine.
\end{itemize}
However there are quite a few issues with this algorithm, issues that can render the method useless and make it obsolete in a faster than normal timeframe:
\begin{itemize}
  \item \textbf{No data redundancy}. There is absolutely no mechanism in place in order to prevent the loss of data. Most communication environments nowadays usually compress the files before sending them over the wire and that compression may be lossless, but in most cases it is lossy. And even by sending the file in a way that it will not be compressed, there is also the slight change of altering and a small change in a single bit can and it will make the whole secret message corrupted without any method of recovery.
  \item \textbf{Detection via pattern identification}. Working only within small sub-blocks of BLOCK\_SIZE means that we also limit the attack surface of any outside parties and allow them to focus on finding any details that can help them identify the key that was used when encoding the secret. For example, it is possible that an attacker will want to focus on the second block of the cover file and try to search for common extensions in the secret embedded file headers. If the intruder finds there is an order to the bytes of the block which produce that header that means that he is much closer to identifying the seed of the pseudo-random engine because he knows the second permutation generated by that seed and based on that information he may be able to deduct further permutations.
  \item \textbf{Limited market}. This algorithm was designed with file formats that are lossless, i.e. bitmaps that store the entire information of the image. While theoretically it could be used for PNGs as well, we will see in later chapters that PNG uses a mechanism called interlacing which makes it harder to work or even identify the sub-blocks of the image. Most modern online platforms have also moved away from BMP since they are far too big in size and the same image quality could be achieved by using other formats that have a much much smaller size, ending up in almost making the entire BMP format obsolete.
\end{itemize}
In the end, it is important to note that similar work has been done by a few researchers, the closest one being the work done by Hussein Al-Bahadili\cite{secure_block_permutation} in his paper where he chose to focus on scrambling the contents of the secret message using a similar password and seed generation technique before writing it to the carrier file. But while the 2 methods are similar in their goal, the way they reach that goal are different.


\section{Portable Network Graphics (PNG)} \label{PNG_Explained_Chapter}


\end{multicols*}
